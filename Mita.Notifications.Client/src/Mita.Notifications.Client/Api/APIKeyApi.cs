/*
 * MITA Notifications Platform REST API
 *
 * The Notifications REST API allows programmatic access to the Notifications Portal message funtionality. To use the REST API, you will need a Notifications Portal Account and an API key and secret. You can generate from the Notifications Portal using the API Key Manager.The REST API takes full advantage of all HTTP headers. Each part of a request and response is meaningful, including the request method (GET/POST, etc.), the individual headers (Location, Content-Type, Accept, etc.), and the response status code (200, 400, 404, etc.). Use of this API assumes a working knowledge of these HTTP components, and general use of RESTful web APIs.
 *
 * The version of the OpenAPI document: v1
 * Contact: notifications.mita@gov.mt
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Mime;
using System.Threading.Tasks;
using Mita.Notifications.Client.Client;
using Mita.Notifications.Client.Model;

namespace Mita.Notifications.Client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAPIKeyApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Use this API to refresh an expired API Key and obtain a new Secret Key.    Please note that API Secret Keys expire after seven days by default.   When this key expires, the user needs to refresh the API Secret Key  using this endpoint to generate a new secret key.     You can obtain a new Secret Key the expired Secret Key.
        /// </summary>
        /// <exception cref="Mita.Notifications.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiKey</returns>
        ApiKey GetApiV1Key();

        /// <summary>
        /// Use this API to refresh an expired API Key and obtain a new Secret Key.    Please note that API Secret Keys expire after seven days by default.   When this key expires, the user needs to refresh the API Secret Key  using this endpoint to generate a new secret key.     You can obtain a new Secret Key the expired Secret Key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Mita.Notifications.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of ApiKey</returns>
        ApiResponse<ApiKey> GetApiV1KeyWithHttpInfo();
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAPIKeyApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Use this API to refresh an expired API Key and obtain a new Secret Key.    Please note that API Secret Keys expire after seven days by default.   When this key expires, the user needs to refresh the API Secret Key  using this endpoint to generate a new secret key.     You can obtain a new Secret Key the expired Secret Key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Mita.Notifications.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiKey</returns>
        System.Threading.Tasks.Task<ApiKey> GetApiV1KeyAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Use this API to refresh an expired API Key and obtain a new Secret Key.    Please note that API Secret Keys expire after seven days by default.   When this key expires, the user needs to refresh the API Secret Key  using this endpoint to generate a new secret key.     You can obtain a new Secret Key the expired Secret Key.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Mita.Notifications.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ApiKey)</returns>
        System.Threading.Tasks.Task<ApiResponse<ApiKey>> GetApiV1KeyWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IAPIKeyApi : IAPIKeyApiSync, IAPIKeyApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class APIKeyApi :  IAPIKeyApi
    {
        private Mita.Notifications.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="APIKeyApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <returns></returns>
        public APIKeyApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="APIKeyApi"/> class.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="basePath">The target service's base path in URL format.</param>
        /// <exception cref="ArgumentException"></exception>
        /// <returns></returns>
        public APIKeyApi(string basePath)
        {
            this.Configuration = Mita.Notifications.Client.Client.Configuration.MergeConfigurations(
                Mita.Notifications.Client.Client.GlobalConfiguration.Instance,
                new Mita.Notifications.Client.Client.Configuration { BasePath = basePath }
            );
            this.ApiClient = new Mita.Notifications.Client.Client.ApiClient(this.Configuration.BasePath);
            this.Client =  this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            this.ExceptionFactory = Mita.Notifications.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="APIKeyApi"/> class using Configuration object.
        /// **IMPORTANT** This will also create an instance of HttpClient, which is less than ideal.
        /// It's better to reuse the <see href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests#issues-with-the-original-httpclient-class-available-in-net">HttpClient and HttpClientHandler</see>.
        /// </summary>
        /// <param name="configuration">An instance of Configuration.</param>
        /// <exception cref="ArgumentNullException"></exception>
        /// <returns></returns>
        public APIKeyApi(Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Mita.Notifications.Client.Client.Configuration.MergeConfigurations(
                Mita.Notifications.Client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.ApiClient = new Mita.Notifications.Client.Client.ApiClient(this.Configuration.BasePath);
            this.Client = this.ApiClient;
            this.AsynchronousClient = this.ApiClient;
            ExceptionFactory = Mita.Notifications.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="APIKeyApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public APIKeyApi(Mita.Notifications.Client.Client.ISynchronousClient client, Mita.Notifications.Client.Client.IAsynchronousClient asyncClient, Mita.Notifications.Client.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Mita.Notifications.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Holds the ApiClient if created
        /// </summary>
        public Mita.Notifications.Client.Client.ApiClient ApiClient { get; set; } = null;

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Mita.Notifications.Client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Mita.Notifications.Client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Mita.Notifications.Client.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Mita.Notifications.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Use this API to refresh an expired API Key and obtain a new Secret Key.    Please note that API Secret Keys expire after seven days by default.   When this key expires, the user needs to refresh the API Secret Key  using this endpoint to generate a new secret key.     You can obtain a new Secret Key the expired Secret Key. 
        /// </summary>
        /// <exception cref="Mita.Notifications.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiKey</returns>
        public ApiKey GetApiV1Key()
        {
            Mita.Notifications.Client.Client.ApiResponse<ApiKey> localVarResponse = GetApiV1KeyWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Use this API to refresh an expired API Key and obtain a new Secret Key.    Please note that API Secret Keys expire after seven days by default.   When this key expires, the user needs to refresh the API Secret Key  using this endpoint to generate a new secret key.     You can obtain a new Secret Key the expired Secret Key. 
        /// </summary>
        /// <exception cref="Mita.Notifications.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of ApiKey</returns>
        public Mita.Notifications.Client.Client.ApiResponse<ApiKey> GetApiV1KeyWithHttpInfo()
        {
            Mita.Notifications.Client.Client.RequestOptions localVarRequestOptions = new Mita.Notifications.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/xml"
            };

            var localVarContentType = Mita.Notifications.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Mita.Notifications.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<ApiKey>("/api/v1/key", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetApiV1Key", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Use this API to refresh an expired API Key and obtain a new Secret Key.    Please note that API Secret Keys expire after seven days by default.   When this key expires, the user needs to refresh the API Secret Key  using this endpoint to generate a new secret key.     You can obtain a new Secret Key the expired Secret Key. 
        /// </summary>
        /// <exception cref="Mita.Notifications.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiKey</returns>
        public async Task<ApiKey> GetApiV1KeyAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            ApiResponse<ApiKey> localVarResponse = await GetApiV1KeyWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Use this API to refresh an expired API Key and obtain a new Secret Key.    Please note that API Secret Keys expire after seven days by default.   When this key expires, the user needs to refresh the API Secret Key  using this endpoint to generate a new secret key.     You can obtain a new Secret Key the expired Secret Key. 
        /// </summary>
        /// <exception cref="Mita.Notifications.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ApiKey)</returns>
        public async Task<ApiResponse<ApiKey>> GetApiV1KeyWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Mita.Notifications.Client.Client.RequestOptions localVarRequestOptions = new Mita.Notifications.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json",
                "application/xml"
            };


            var localVarContentType = Mita.Notifications.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Mita.Notifications.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<ApiKey>("/api/v1/key", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetApiV1Key", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }
    }
}
