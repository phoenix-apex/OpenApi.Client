/*
 * MITA Notifications Platform REST API
 *
 * The Notifications REST API allows programmatic access to the Notifications Portal message funtionality. To use the REST API, you will need a Notifications Portal Account and an API key and secret. You can generate from the Notifications Portal using the API Key Manager.The REST API takes full advantage of all HTTP headers. Each part of a request and response is meaningful, including the request method (GET/POST, etc.), the individual headers (Location, Content-Type, Accept, etc.), and the response status code (200, 400, 404, etc.). Use of this API assumes a working knowledge of these HTTP components, and general use of RESTful web APIs.
 *
 * The version of the OpenAPI document: v1
 * Contact: notifications.mita@gov.mt
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http.Headers;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using Mita.Notifications.Client.Model;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;
using RestSharp;
using RestSharpMethod = RestSharp.Method;
using Polly;
using Encoding = System.Text.Encoding;

namespace Mita.Notifications.Client.Client;

/// <summary>
/// Provides a default implementation of an Api client (both synchronous and asynchronous implementations),
/// encapsulating general REST accessor use cases.
/// </summary>
public partial class ApiClient : ISynchronousClient, IAsynchronousClient
{
    private readonly string _baseUrl;
    private string AuthScheme { get; } = "SMG-V1-HMAC-SHA256";
    private string Nonce { get; } = Guid.NewGuid().ToString();
    private double UnixTimeSeconds { get; } = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

    /// <summary>
    /// Specifies the settings on a <see cref="JsonSerializer" /> object.
    /// These settings can be adjusted to accommodate custom serialization rules.
    /// </summary>
    public JsonSerializerSettings SerializerSettings { get; set; } = new JsonSerializerSettings {
        // OpenAPI generated types generally hide default constructors.
        ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
        ContractResolver = new DefaultContractResolver {
            NamingStrategy = new CamelCaseNamingStrategy
            {
                OverrideSpecifiedNames = false
            }
        },
        MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
        DateParseHandling = DateParseHandling.None,
        Converters = {
            new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
        },
    };

    /// <summary>
    /// Allows for extending request processing for <see cref="ApiClient"/> generated code.
    /// </summary>
    /// <param name="request">The RestSharp request object</param>
    partial void InterceptRequest(RestRequest request);

    /// <summary>
    /// Allows for extending response processing for <see cref="ApiClient"/> generated code.
    /// </summary>
    /// <param name="request">The RestSharp request object</param>
    /// <param name="response">The RestSharp response object</param>
    partial void InterceptResponse(RestRequest request, RestResponse response);

    /// <summary>
    /// Initializes a new instance of the <see cref="ApiClient" />, defaulting to the global configurations' base url.
    /// </summary>
    public ApiClient()
    {
        _baseUrl = Mita.Notifications.Client.Client.GlobalConfiguration.Instance.BasePath;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ApiClient" />
    /// </summary>
    /// <param name="basePath">The target service's base path in URL format.</param>
    /// <exception cref="ArgumentException"></exception>
    public ApiClient(string basePath)
    {
        if (string.IsNullOrEmpty(basePath))
            throw new ArgumentException("basePath cannot be empty");

        _baseUrl = basePath;
    }

    /// <summary>
    /// Constructs the RestSharp version of an http method
    /// </summary>
    /// <param name="method">Swagger Client Custom HttpMethod</param>
    /// <returns>RestSharp's HttpMethod instance.</returns>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    private RestSharpMethod Method(HttpMethod method)
    {
        RestSharpMethod other;
        switch (method)
        {
            case HttpMethod.Get:
                other = RestSharpMethod.Get;
                break;
            case HttpMethod.Post:
                other = RestSharpMethod.Post;
                break;
            case HttpMethod.Put:
                other = RestSharpMethod.Put;
                break;
            case HttpMethod.Delete:
                other = RestSharpMethod.Delete;
                break;
            case HttpMethod.Head:
                other = RestSharpMethod.Head;
                break;
            case HttpMethod.Options:
                other = RestSharpMethod.Options;
                break;
            case HttpMethod.Patch:
                other = RestSharpMethod.Patch;
                break;
            default:
                throw new ArgumentOutOfRangeException("method", method, null);
        }

        return other;
    }

    /// <summary>
    /// Provides all logic for constructing a new RestSharp <see cref="RestRequest"/>.
    /// At this point, all information for querying the service is known. Here, it is simply
    /// mapped into the RestSharp request.
    /// </summary>
    /// <param name="method">The http verb.</param>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>[private] A new RestRequest instance.</returns>
    /// <exception cref="ArgumentNullException"></exception>
    private RestRequest NewRequest(HttpMethod method, string path, RequestOptions options, IReadableConfiguration configuration)
    {
        if (path == null) throw new ArgumentNullException("path");
        if (options == null) throw new ArgumentNullException("options");
        if (configuration == null) throw new ArgumentNullException("configuration");

        RestRequest request = new RestRequest(path, Method(method));

        if (options.PathParameters != null)
        {
            foreach (var pathParam in options.PathParameters)
            {
                request.AddParameter(pathParam.Key, pathParam.Value, ParameterType.UrlSegment);
            }
        }

        if (options.QueryParameters != null)
        {
            foreach (var queryParam in options.QueryParameters)
            {
                foreach (var value in queryParam.Value)
                {
                    request.AddQueryParameter(queryParam.Key, value);
                }
            }
        }

        if (configuration.DefaultHeaders != null)
        {
            foreach (var headerParam in configuration.DefaultHeaders)
            {
                request.AddHeader(headerParam.Key, headerParam.Value);
            }
        }

        if (options.HeaderParameters != null)
        {
            foreach (var headerParam in options.HeaderParameters)
            {
                foreach (var value in headerParam.Value)
                {
                    request.AddHeader(headerParam.Key, value);
                }
            }
        }

        if (options.FormParameters != null)
        {
            foreach (var formParam in options.FormParameters)
            {
                request.AddParameter(formParam.Key, formParam.Value);
            }
        }

        if (options.Data is not null)
        {
            if (options.Data is Stream stream)
            {
                var contentType = "application/octet-stream";
                if (options.HeaderParameters != null)
                {
                    var contentTypes = options.HeaderParameters["Content-Type"];
                    contentType = contentTypes[0];
                }

                var bytes = ClientUtils.ReadAsBytes(stream);
                request.AddParameter(contentType, bytes, ParameterType.RequestBody);
            }
            else
            {
                if (options.HeaderParameters != null)
                {
                    var contentTypes = options.HeaderParameters["Content-Type"];
                    if (contentTypes == null || contentTypes.Any(header => header.Contains("application/json")))
                    {
                        request.RequestFormat = DataFormat.Json;
                    }
                    else
                    {
                        // TODO: Generated client user should add additional handlers. RestSharp only supports XML and JSON, with XML as default.
                    }
                }
                else
                {
                    // Here, we'll assume JSON APIs are more common. XML can be forced by adding produces/consumes to openapi spec explicitly.
                    request.RequestFormat = DataFormat.Json;
                }
                
                var json = JsonConvert.SerializeObject(options.Data, SerializerSettings);
                
                request.AddStringBody(json, DataFormat.Json);
            }
        }

        if (options.FileParameters != null)
        {
            foreach (var fileParam in options.FileParameters)
            {
                foreach (var file in fileParam.Value)
                {
                    var bytes = ClientUtils.ReadAsBytes(file);
                    var fileStream = file as FileStream;
                    if (fileStream != null)
                        request.AddFile(fileParam.Key, bytes, System.IO.Path.GetFileName(fileStream.Name));
                    else
                        request.AddFile(fileParam.Key, bytes, "no_file_name_provided");
                }
            }
        }

        return request;
    }

    private ApiResponse<T> ToApiResponse<T>(RestResponse<T> response)
    {
        T result = response.Data;
        string rawContent = response.Content;

        var transformed = new ApiResponse<T>(response.StatusCode, new Multimap<string, string>(StringComparer.OrdinalIgnoreCase), result, rawContent)
        {
            ErrorText = response.ErrorMessage,
            Cookies = new List<Cookie>()
        };

        if (response.Headers != null)
        {
            foreach (var responseHeader in response.Headers)
            {
                transformed.Headers.Add(responseHeader.Name, ClientUtils.ParameterToString(responseHeader.Value));
            }
        }

        if (response.ContentHeaders != null)
        {
            foreach (var responseHeader in response.ContentHeaders)
            {
                transformed.Headers.Add(responseHeader.Name, ClientUtils.ParameterToString(responseHeader.Value));
            }
        }

        if (response.Cookies != null)
        {
            foreach (var responseCookies in response.Cookies.Cast<Cookie>())
            {
                transformed.Cookies.Add(
                    new Cookie(
                        responseCookies.Name,
                        responseCookies.Value,
                        responseCookies.Path,
                        responseCookies.Domain)
                );
            }
        }

        return transformed;
    }
    
    /// <summary>
    ///  Get the resource path i.e. remove the /api/v1/ from the path
    /// </summary>
    /// <param name="path"></param>
    /// <returns></returns>
    private string GetResourcePath(string path)
    {
        return string.Join("/", path.Split('/').Skip(3));
    }

    private ApiResponse<T> Exec<T>(RestRequest request, RequestOptions options, IReadableConfiguration configuration)
    {
        var baseUrl = configuration.GetOperationServerUrl(options.Operation, options.OperationIndex) ?? _baseUrl;

        var cookies = new CookieContainer();

        if (options.Cookies != null && options.Cookies.Count > 0)
        {
            foreach (var cookie in options.Cookies)
            {
                cookies.Add(new Cookie(cookie.Name, cookie.Value));
            }
        }

        var clientOptions = new RestClientOptions(baseUrl)
        {
            ClientCertificates = configuration.ClientCertificates,
            CookieContainer = cookies,
            MaxTimeout = configuration.Timeout,
            Proxy = configuration.Proxy,
            UserAgent = configuration.UserAgent,
            UseDefaultCredentials = configuration.UseDefaultCredentials,
            RemoteCertificateValidationCallback = configuration.RemoteCertificateValidationCallback
        };
        

        using (RestClient client = new RestClient(clientOptions, configureDefaultHeaders: headers => headers.Authorization = BuildAuthHeader(configuration.Key, configuration.Secret, request.Resource, options.Data, request.Method), configureSerialization: serializerConfig => serializerConfig.UseSerializer(() => new CustomJsonCodec(SerializerSettings, configuration))))
        {
            InterceptRequest(request);

            RestResponse<T> response;
            if (RetryConfiguration.RetryPolicy != null)
            {
                var policy = RetryConfiguration.RetryPolicy;
                var policyResult = policy.ExecuteAndCapture(() => client.Execute(request));
                response = (policyResult.Outcome == OutcomeType.Successful) ? client.Deserialize<T>(policyResult.Result) : new RestResponse<T>(request)
                {
                    ErrorException = policyResult.FinalException
                };
            }
            else
            {
                try
                {
                    response = client.Execute<T>(request);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e);
                    throw;
                }
            }

            // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
            if (typeof(Mita.Notifications.Client.Model.AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
            {
                try
                {
                    response.Data = (T) typeof(T).GetMethod("FromJson").Invoke(null, new object[] { response.Content });
                }
                catch (Exception ex)
                {
                    throw ex.InnerException != null ? ex.InnerException : ex;
                }
            }
            else if (typeof(T).Name == "Stream") // for binary response
            {
                response.Data = (T)(object)new MemoryStream(response.RawBytes);
            }
            else if (typeof(T).Name == "Byte[]") // for byte response
            {
                response.Data = (T)(object)response.RawBytes;
            }
            else if (typeof(T).Name == "String") // for string response
            {
                response.Data = (T)(object)response.Content;
            }

            InterceptResponse(request, response);

            var result = ToApiResponse(response);
            if (response.ErrorMessage != null)
            {
                result.ErrorText = response.ErrorMessage;
            }

            if (response.Cookies != null && response.Cookies.Count > 0)
            {
                if (result.Cookies == null) result.Cookies = new List<Cookie>();
                foreach (var restResponseCookie in response.Cookies.Cast<Cookie>())
                {
                    var cookie = new Cookie(
                        restResponseCookie.Name,
                        restResponseCookie.Value,
                        restResponseCookie.Path,
                        restResponseCookie.Domain
                    )
                    {
                        Comment = restResponseCookie.Comment,
                        CommentUri = restResponseCookie.CommentUri,
                        Discard = restResponseCookie.Discard,
                        Expired = restResponseCookie.Expired,
                        Expires = restResponseCookie.Expires,
                        HttpOnly = restResponseCookie.HttpOnly,
                        Port = restResponseCookie.Port,
                        Secure = restResponseCookie.Secure,
                        Version = restResponseCookie.Version
                    };

                    result.Cookies.Add(cookie);
                }
            }
            return result;
        }
    }

    private async Task<ApiResponse<T>> ExecAsync<T>(RestRequest request, RequestOptions options, IReadableConfiguration configuration, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {
        var baseUrl = configuration.GetOperationServerUrl(options.Operation, options.OperationIndex) ?? _baseUrl;

        var clientOptions = new RestClientOptions(baseUrl)
        {
            ClientCertificates = configuration.ClientCertificates,
            MaxTimeout = configuration.Timeout,
            Proxy = configuration.Proxy,
            UserAgent = configuration.UserAgent,
            UseDefaultCredentials = configuration.UseDefaultCredentials,
            RemoteCertificateValidationCallback = configuration.RemoteCertificateValidationCallback
        };
        
        using (RestClient client = new RestClient(clientOptions, configureDefaultHeaders: headers => headers.Authorization = BuildAuthHeader(configuration.Key, configuration.Secret, request.Resource, options.Data, request.Method), configureSerialization: serializerConfig => serializerConfig.UseSerializer(() => new CustomJsonCodec(SerializerSettings, configuration))))
        {
            InterceptRequest(request);

            RestResponse<T> response;
            if (RetryConfiguration.AsyncRetryPolicy != null)
            {
                var policy = RetryConfiguration.AsyncRetryPolicy;
                var policyResult = await policy.ExecuteAndCaptureAsync((ct) => client.ExecuteAsync(request, ct), cancellationToken).ConfigureAwait(false);
                response = (policyResult.Outcome == OutcomeType.Successful) ? client.Deserialize<T>(policyResult.Result) : new RestResponse<T>(request) { ErrorException = policyResult.FinalException };
            }
            else
            {
                response = await client.ExecuteAsync<T>(request, cancellationToken).ConfigureAwait(false);
                if(!response.IsSuccessStatusCode) throw new ApiException((int)response.StatusCode, response.ErrorMessage, response.ErrorException);
            }

            // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
            if (typeof(Mita.Notifications.Client.Model.AbstractOpenAPISchema).IsAssignableFrom(typeof(T)))
            {
                response.Data = (T) typeof(T).GetMethod("FromJson").Invoke(null, new object[] { response.Content });
            }
            else if (typeof(T).Name == "Stream") // for binary response
            {
                response.Data = (T)(object)new MemoryStream(response.RawBytes);
            }
            else if (typeof(T).Name == "Byte[]") // for byte response
            {
                response.Data = (T)(object)response.RawBytes;
            }

            InterceptResponse(request, response);

            var result = ToApiResponse(response);
            if (response.ErrorMessage != null)
            {
                result.ErrorText = response.ErrorMessage;
            }

            if (response.Cookies != null && response.Cookies.Count > 0)
            {
                if (result.Cookies == null) result.Cookies = new List<Cookie>();
                foreach (var restResponseCookie in response.Cookies.Cast<Cookie>())
                {
                    var cookie = new Cookie(restResponseCookie.Name, restResponseCookie.Value, restResponseCookie.Path, restResponseCookie.Domain) {
                        Comment = restResponseCookie.Comment,
                        CommentUri = restResponseCookie.CommentUri,
                        Discard = restResponseCookie.Discard,
                        Expired = restResponseCookie.Expired,
                        Expires = restResponseCookie.Expires,
                        HttpOnly = restResponseCookie.HttpOnly,
                        Port = restResponseCookie.Port,
                        Secure = restResponseCookie.Secure,
                        Version = restResponseCookie.Version
                    };

                    result.Cookies.Add(cookie);
                }
            }
            return result;
        }
    }

    #region IAsynchronousClient
    /// <summary>
    /// Make a HTTP GET request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> GetAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Get, path, options, config), options, config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP POST request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PostAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Post, path, options, config), options, config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP PUT request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PutAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Put, path, options, config), options, config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP DELETE request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> DeleteAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Delete, path, options, config), options, config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP HEAD request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> HeadAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Head, path, options, config), options, config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP OPTION request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> OptionsAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Options, path, options, config), options, config, cancellationToken);
    }

    /// <summary>
    /// Make a HTTP PATCH request (async).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="cancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PatchAsync<T>(string path, RequestOptions options, IReadableConfiguration configuration = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return ExecAsync<T>(NewRequest(HttpMethod.Patch, path, options, config), options, config, cancellationToken);
    }
    #endregion IAsynchronousClient

    #region ISynchronousClient
    /// <summary>
    /// Make a HTTP GET request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Get<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Get, path, options, config), options, config);
    }

    /// <summary>
    /// Make a HTTP POST request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Post<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Post, path, options, config), options, config);
    }

    /// <summary>
    /// Make a HTTP PUT request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Put<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Put, path, options, config), options, config);
    }

    /// <summary>
    /// Make a HTTP DELETE request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Delete<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Delete, path, options, config), options, config);
    }

    /// <summary>
    /// Make a HTTP HEAD request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Head<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Head, path, options, config), options, config);
    }

    /// <summary>
    /// Make a HTTP OPTION request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Options<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Options, path, options, config), options, config);
    }

    /// <summary>
    /// Make a HTTP PATCH request (synchronous).
    /// </summary>
    /// <param name="path">The target path (or resource).</param>
    /// <param name="options">The additional request options.</param>
    /// <param name="configuration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Patch<T>(string path, RequestOptions options, IReadableConfiguration configuration = null)
    {
        var config = configuration ?? GlobalConfiguration.Instance;
        return Exec<T>(NewRequest(HttpMethod.Patch, path, options, config), options, config);
    }
    #endregion ISynchronousClient
        
    private AuthenticationHeaderValue BuildAuthHeader(string key, string secret, string resource, object payload = null, Method method = RestSharpMethod.Get)
    {
        if (string.IsNullOrWhiteSpace(key) || string.IsNullOrWhiteSpace(secret))
            throw new ArgumentException("Key and secret must be provided to build the authentication header.");
        
        var uri = Uri.EscapeDataString($"{_baseUrl}{resource}").ToLowerInvariant();

        using var sha256 = SHA256.Create();
        var body = payload is not null ? JsonConvert.SerializeObject(payload, SerializerSettings) : string.Empty;
        var bodyHash = string.IsNullOrWhiteSpace(body)
            ? string.Empty
            : Convert.ToBase64String(sha256.ComputeHash(Encoding.UTF8.GetBytes(body)));
        var httpMethod = method.ToString().ToUpper();
        var mac = $"{key}\n{httpMethod}\n{uri}\n{UnixTimeSeconds}\n{Nonce}\n{bodyHash}";
        var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(secret));
        var hashedMac = hmac.ComputeHash(Encoding.UTF8.GetBytes(mac));
        var base64Mac = Convert.ToBase64String(hashedMac);
        var authHeader = $"id=\"{key}\",ts=\"{UnixTimeSeconds}\",nonce=\"{Nonce}\",mac=\"{base64Mac}\"";
        var authHeaderFull = $"{authHeader}";
        return new AuthenticationHeaderValue(scheme: AuthScheme, authHeaderFull);
    }
}